// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: reservation.sql

package db

import (
	"context"
	"time"
)

const createReservation = `-- name: CreateReservation :one
INSERT INTO reservations (
  table_size, start_time, booked, duration
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, table_size, start_time, booked, duration
`

type CreateReservationParams struct {
	TableSize int32     `json:"table_size"`
	StartTime time.Time `json:"start_time"`
	Booked    bool      `json:"booked"`
	Duration  int32     `json:"duration"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (Reservation, error) {
	row := q.queryRow(ctx, q.createReservationStmt, createReservation,
		arg.TableSize,
		arg.StartTime,
		arg.Booked,
		arg.Duration,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.TableSize,
		&i.StartTime,
		&i.Booked,
		&i.Duration,
	)
	return i, err
}

const deleteReservation = `-- name: DeleteReservation :exec
DELETE FROM reservations
WHERE id = $1
`

func (q *Queries) DeleteReservation(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteReservationStmt, deleteReservation, id)
	return err
}

const getOptimizedReservation = `-- name: GetOptimizedReservation :one
SELECT id, table_size, start_time, booked, duration FROM reservations
WHERE reservations.start_time = $1 and 
reservations.booked = $2 and 
reservations.table_size = (
  SELECT MIN(table_size)
    FROM (SELECT id, table_size, start_time, booked, duration FROM reservations 
      WHERE reservations.table_size >= $3 AND reservations.booked = $2 AND 
      reservations.start_time = $1) AS subquery
  ) 
LIMIT 1
`

type GetOptimizedReservationParams struct {
	StartTime time.Time `json:"start_time"`
	Booked    bool      `json:"booked"`
	TableSize int32     `json:"table_size"`
}

func (q *Queries) GetOptimizedReservation(ctx context.Context, arg GetOptimizedReservationParams) (Reservation, error) {
	row := q.queryRow(ctx, q.getOptimizedReservationStmt, getOptimizedReservation, arg.StartTime, arg.Booked, arg.TableSize)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.TableSize,
		&i.StartTime,
		&i.Booked,
		&i.Duration,
	)
	return i, err
}

const getReservation = `-- name: GetReservation :one
SELECT id, table_size, start_time, booked, duration FROM reservations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetReservation(ctx context.Context, id int64) (Reservation, error) {
	row := q.queryRow(ctx, q.getReservationStmt, getReservation, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.TableSize,
		&i.StartTime,
		&i.Booked,
		&i.Duration,
	)
	return i, err
}

const listAvailableReservations = `-- name: ListAvailableReservations :many
SELECT id, table_size, start_time, booked, duration FROM reservations
WHERE booked = false
ORDER BY start_time
LIMIT $1
OFFSET $2
`

type ListAvailableReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAvailableReservations(ctx context.Context, arg ListAvailableReservationsParams) ([]Reservation, error) {
	rows, err := q.query(ctx, q.listAvailableReservationsStmt, listAvailableReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.TableSize,
			&i.StartTime,
			&i.Booked,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservations = `-- name: ListReservations :many
SELECT id, table_size, start_time, booked, duration FROM reservations
ORDER BY start_time
LIMIT $1
OFFSET $2
`

type ListReservationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListReservations(ctx context.Context, arg ListReservationsParams) ([]Reservation, error) {
	rows, err := q.query(ctx, q.listReservationsStmt, listReservations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.TableSize,
			&i.StartTime,
			&i.Booked,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReservation = `-- name: UpdateReservation :one
UPDATE reservations
SET table_size = $2,
start_time = $3,
booked = $4,
duration = $5
WHERE id = $1
RETURNING id, table_size, start_time, booked, duration
`

type UpdateReservationParams struct {
	ID        int64     `json:"id"`
	TableSize int32     `json:"table_size"`
	StartTime time.Time `json:"start_time"`
	Booked    bool      `json:"booked"`
	Duration  int32     `json:"duration"`
}

func (q *Queries) UpdateReservation(ctx context.Context, arg UpdateReservationParams) (Reservation, error) {
	row := q.queryRow(ctx, q.updateReservationStmt, updateReservation,
		arg.ID,
		arg.TableSize,
		arg.StartTime,
		arg.Booked,
		arg.Duration,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.TableSize,
		&i.StartTime,
		&i.Booked,
		&i.Duration,
	)
	return i, err
}
